{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"0index/","text":"HELLO WORLD ! - Selamat Datang di Webstatis_Saya \u00b6 Nama: Mochamad Salim Ubaidillah \u00b6 NIM: 170411100097 \u00b6 Program Studi S1 Teknik Informatika Fakultas Teknik Universitas Trunojoyo Madura - Web ini dibuat untuk \u00b6 Membagikan ilmu yang saya terima selama menempuh mata kuliah Komputasi Numerik Komputasi Numerik . Memenuhi tugas perkuliahan komputasi numerik yang diampu oleh Bapak Mula'ab, S.Si., M.Kom. Bapak Mula'ab, S.Si., M.Kom.","title":"0-Tentang Penulis"},{"location":"0index/#hello-world-selamat-datang-di-webstatis_saya","text":"","title":"HELLO WORLD ! - Selamat Datang di Webstatis_Saya"},{"location":"0index/#nama-mochamad-salim-ubaidillah","text":"","title":"Nama: Mochamad Salim Ubaidillah"},{"location":"0index/#nim-170411100097","text":"Program Studi S1 Teknik Informatika Fakultas Teknik Universitas Trunojoyo Madura -","title":"NIM: 170411100097"},{"location":"0index/#web-ini-dibuat-untuk","text":"Membagikan ilmu yang saya terima selama menempuh mata kuliah Komputasi Numerik Komputasi Numerik . Memenuhi tugas perkuliahan komputasi numerik yang diampu oleh Bapak Mula'ab, S.Si., M.Kom. Bapak Mula'ab, S.Si., M.Kom.","title":"Web ini dibuat untuk"},{"location":"1deret/","text":"TUGAS 1 - Deret Mclaurin \u00b6 Pengertian \u00b6 Deret Mclaurin yaitu sebuah fungsi yang memiliki turunan yang kontintu pada intervalnya, yang terekspansi dalam deret taylor. Pada dasarnya deret maclaurin masih berhubungan dengan deret taylor, namun memiliki fungsi yang diekspansi sekitar c = 0 . Deret Maclaurin biasanya disebut juga deret taylor baku. Atau bisa didefinisikan sebagai berikut: f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(0)}{n !} x^{n} f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(0)}{n !} x^{n} Contoh \u00b6 Misal pada perhitungan bilangan irasional e e = 2,718... . Bilangan tersebut bisa juga dinamakan basis natural. Soal \u00b6 tentukan e^{2 x} e^{2 x} dengan x x = 4 dan ekspansi eror < 0,001. . Penyelesaian \u00b6 Langkah 1 \u00b6 Buat tabel perhitungan untuk turunan, agar mudah dalam perhitungan \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{(1)}(x) & 2 e^{2 x} & f^{(1)}(0)=2 \\\\ \\hline f^{(2)}(x) & 4 e^{2 x} & f^{(2)}(0)=4 \\\\ \\hline f^{(3)}(x) & 8 e^{2 x} & f^{(3)}(0)=8 \\\\ \\hline f^{(4)}(x) & 16 e^{2 x} & f^{(4)}(0)=16 \\\\ \\hline \\hline ... & ... & ... \\\\ \\hline ... & ... & ... \\\\ \\hline f^{(n)}(x) & 2^{n} e^{2 x} & f^{(n)}(0)=2^{n} \\\\ \\hline \\end{array} \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{(1)}(x) & 2 e^{2 x} & f^{(1)}(0)=2 \\\\ \\hline f^{(2)}(x) & 4 e^{2 x} & f^{(2)}(0)=4 \\\\ \\hline f^{(3)}(x) & 8 e^{2 x} & f^{(3)}(0)=8 \\\\ \\hline f^{(4)}(x) & 16 e^{2 x} & f^{(4)}(0)=16 \\\\ \\hline \\hline ... & ... & ... \\\\ \\hline ... & ... & ... \\\\ \\hline f^{(n)}(x) & 2^{n} e^{2 x} & f^{(n)}(0)=2^{n} \\\\ \\hline \\end{array} Langkah 2 \u00b6 Setelah membuat tabel perhitungan turunan, tinggal masukan ke formula yang telah dijabarkan dengan mengganti nilai x x . Penjabaran Formula f(x)=f(0)+\\frac{f^{(1)}(0)}{1 !} x+\\frac{f^{(2)}(0)}{2 !} x^{2}+\\frac{f^{(3)}(0)}{3 !} x^{3}+\\frac{f^{(4)}(0)}{4 !} x^{4} + ... +\\frac{f^{(n)}(0)}{n !} x^{n} f(x)=f(0)+\\frac{f^{(1)}(0)}{1 !} x+\\frac{f^{(2)}(0)}{2 !} x^{2}+\\frac{f^{(3)}(0)}{3 !} x^{3}+\\frac{f^{(4)}(0)}{4 !} x^{4} + ... +\\frac{f^{(n)}(0)}{n !} x^{n} Ganti fungsi turunan sehingga didapatkan seperti dibawah f(x)=1+\\frac{2}{1 !} x+\\frac{4}{2 !} x^{2}+\\frac{8}{3 !} x^{3}+\\frac{16}{4 !} x^{4} + ... + \\frac{2^n}{n!} x^{n} f(x)=1+\\frac{2}{1 !} x+\\frac{4}{2 !} x^{2}+\\frac{8}{3 !} x^{3}+\\frac{16}{4 !} x^{4} + ... + \\frac{2^n}{n!} x^{n} Langkah 3 \u00b6 Masukkan nilai x x ke dalam formula, sehingga didapatkan hasilnya. f(x)=1+\\frac{2}{1 !} 4+\\frac{4}{2 !} 4^{2}+\\frac{8}{3 !} 4^{3}+\\frac{16}{4 !} 4^{4} + ... + \\frac{2^n}{n!} 4^{n} f(x)=1+\\frac{2}{1 !} 4+\\frac{4}{2 !} 4^{2}+\\frac{8}{3 !} 4^{3}+\\frac{16}{4 !} 4^{4} + ... + \\frac{2^n}{n!} 4^{n} Langkah 4 \u00b6 Ulangi proses sampai menemukan hasil eror < 0,001. Atau bisa menggunakan program dari python. Program Python \u00b6 import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 2 ** j ) * x ** j / math . factorial ( j ) check = f_y - f_x a += 1 b += 1 print ( ' \\n iterasi ke-' , a , 'eror =' , check ) print ( 'hasil perhitungannya' , f_y ) . maka akan mendapatkan hasil seperti dibawah ini: iterasi ke - 1 eror = 1.0 hasil perhitungannya 1.0 iterasi ke - 2 eror = 8.0 hasil perhitungannya 9.0 iterasi ke - 3 eror = 32.0 hasil perhitungannya 41.0 iterasi ke - 4 eror = 85.33333333333333 hasil perhitungannya 126.33333333333333 iterasi ke - 5 eror = 170.66666666666669 hasil perhitungannya 297.0 iterasi ke - 6 eror = 273.0666666666666 hasil perhitungannya 570.0666666666666 iterasi ke - 7 eror = 364.08888888888896 hasil perhitungannya 934.1555555555556 iterasi ke - 8 eror = 416.1015873015872 hasil perhitungannya 1350.2571428571428 iterasi ke - 9 eror = 416.1015873015872 hasil perhitungannya 1766.35873015873 iterasi ke - 10 eror = 369.8680776014112 hasil perhitungannya 2136.226807760141 iterasi ke - 11 eror = 295.89446208112895 hasil perhitungannya 2432.12126984127 iterasi ke - 12 eror = 215.195972422639 hasil perhitungannya 2647.317242263909 iterasi ke - 13 eror = 143.46398161509296 hasil perhitungannya 2790.781223879002 iterasi ke - 14 eror = 88.28552714774924 hasil perhitungannya 2879.0667510267513 iterasi ke - 15 eror = 50.448872655856576 hasil perhitungannya 2929.515623682608 iterasi ke - 16 eror = 26.90606541645684 hasil perhitungannya 2956.4216890990647 iterasi ke - 17 eror = 13.45303270822842 hasil perhitungannya 2969.874721807293 iterasi ke - 18 eror = 6.330838921519444 hasil perhitungannya 2976.2055607288125 iterasi ke - 19 eror = 2.8137061873417224 hasil perhitungannya 2979.0192669161543 iterasi ke - 20 eror = 1.184718394670199 hasil perhitungannya 2980.2039853108245 iterasi ke - 21 eror = 0.47388735786807956 hasil perhitungannya 2980.6778726686925 iterasi ke - 22 eror = 0.18052851728316455 hasil perhitungannya 2980.8584011859757 iterasi ke - 23 eror = 0.06564673355751438 hasil perhitungannya 2980.924047919533 iterasi ke - 24 eror = 0.022833646454728296 hasil perhitungannya 2980.946881565988 iterasi ke - 25 eror = 0.0076112154847578495 hasil perhitungannya 2980.9544927814727 iterasi ke - 26 eror = 0.0024355889549951826 hasil perhitungannya 2980.9569283704277 iterasi ke - 27 eror = 0.0007494119863622473 hasil perhitungannya 2980.957677782414 . looping berhenti pada iterasi ke-27 karena eror < 0,001. Jadi dapat disimpulkan bahwa e^{2 x} e^{2 x} dengan x x = 4 dan ekspansi eror < 0,001 berhenti pada iterasi ke-27 dengan nilai eror 0,0007494119863622473. Sehingga e^8 e^8 = 2.980,9579870417282747\u202c dan e^{27} e^{27} = 2.980,957677782414 maka hasil komputasi mendapatkan nilai eror = 0,0007494119863622473","title":"1-Deret Mclaurin"},{"location":"1deret/#tugas-1-deret-mclaurin","text":"","title":"TUGAS 1 - Deret Mclaurin"},{"location":"1deret/#pengertian","text":"Deret Mclaurin yaitu sebuah fungsi yang memiliki turunan yang kontintu pada intervalnya, yang terekspansi dalam deret taylor. Pada dasarnya deret maclaurin masih berhubungan dengan deret taylor, namun memiliki fungsi yang diekspansi sekitar c = 0 . Deret Maclaurin biasanya disebut juga deret taylor baku. Atau bisa didefinisikan sebagai berikut: f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(0)}{n !} x^{n} f(x)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(0)}{n !} x^{n}","title":"Pengertian"},{"location":"1deret/#contoh","text":"Misal pada perhitungan bilangan irasional e e = 2,718... . Bilangan tersebut bisa juga dinamakan basis natural.","title":"Contoh"},{"location":"1deret/#soal","text":"tentukan e^{2 x} e^{2 x} dengan x x = 4 dan ekspansi eror < 0,001. .","title":"Soal"},{"location":"1deret/#penyelesaian","text":"","title":"Penyelesaian"},{"location":"1deret/#langkah-1","text":"Buat tabel perhitungan untuk turunan, agar mudah dalam perhitungan \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{(1)}(x) & 2 e^{2 x} & f^{(1)}(0)=2 \\\\ \\hline f^{(2)}(x) & 4 e^{2 x} & f^{(2)}(0)=4 \\\\ \\hline f^{(3)}(x) & 8 e^{2 x} & f^{(3)}(0)=8 \\\\ \\hline f^{(4)}(x) & 16 e^{2 x} & f^{(4)}(0)=16 \\\\ \\hline \\hline ... & ... & ... \\\\ \\hline ... & ... & ... \\\\ \\hline f^{(n)}(x) & 2^{n} e^{2 x} & f^{(n)}(0)=2^{n} \\\\ \\hline \\end{array} \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{(1)}(x) & 2 e^{2 x} & f^{(1)}(0)=2 \\\\ \\hline f^{(2)}(x) & 4 e^{2 x} & f^{(2)}(0)=4 \\\\ \\hline f^{(3)}(x) & 8 e^{2 x} & f^{(3)}(0)=8 \\\\ \\hline f^{(4)}(x) & 16 e^{2 x} & f^{(4)}(0)=16 \\\\ \\hline \\hline ... & ... & ... \\\\ \\hline ... & ... & ... \\\\ \\hline f^{(n)}(x) & 2^{n} e^{2 x} & f^{(n)}(0)=2^{n} \\\\ \\hline \\end{array}","title":"Langkah 1"},{"location":"1deret/#langkah-2","text":"Setelah membuat tabel perhitungan turunan, tinggal masukan ke formula yang telah dijabarkan dengan mengganti nilai x x . Penjabaran Formula f(x)=f(0)+\\frac{f^{(1)}(0)}{1 !} x+\\frac{f^{(2)}(0)}{2 !} x^{2}+\\frac{f^{(3)}(0)}{3 !} x^{3}+\\frac{f^{(4)}(0)}{4 !} x^{4} + ... +\\frac{f^{(n)}(0)}{n !} x^{n} f(x)=f(0)+\\frac{f^{(1)}(0)}{1 !} x+\\frac{f^{(2)}(0)}{2 !} x^{2}+\\frac{f^{(3)}(0)}{3 !} x^{3}+\\frac{f^{(4)}(0)}{4 !} x^{4} + ... +\\frac{f^{(n)}(0)}{n !} x^{n} Ganti fungsi turunan sehingga didapatkan seperti dibawah f(x)=1+\\frac{2}{1 !} x+\\frac{4}{2 !} x^{2}+\\frac{8}{3 !} x^{3}+\\frac{16}{4 !} x^{4} + ... + \\frac{2^n}{n!} x^{n} f(x)=1+\\frac{2}{1 !} x+\\frac{4}{2 !} x^{2}+\\frac{8}{3 !} x^{3}+\\frac{16}{4 !} x^{4} + ... + \\frac{2^n}{n!} x^{n}","title":"Langkah 2"},{"location":"1deret/#langkah-3","text":"Masukkan nilai x x ke dalam formula, sehingga didapatkan hasilnya. f(x)=1+\\frac{2}{1 !} 4+\\frac{4}{2 !} 4^{2}+\\frac{8}{3 !} 4^{3}+\\frac{16}{4 !} 4^{4} + ... + \\frac{2^n}{n!} 4^{n} f(x)=1+\\frac{2}{1 !} 4+\\frac{4}{2 !} 4^{2}+\\frac{8}{3 !} 4^{3}+\\frac{16}{4 !} 4^{4} + ... + \\frac{2^n}{n!} 4^{n}","title":"Langkah 3"},{"location":"1deret/#langkah-4","text":"Ulangi proses sampai menemukan hasil eror < 0,001. Atau bisa menggunakan program dari python.","title":"Langkah 4"},{"location":"1deret/#program-python","text":"import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 2 ** j ) * x ** j / math . factorial ( j ) check = f_y - f_x a += 1 b += 1 print ( ' \\n iterasi ke-' , a , 'eror =' , check ) print ( 'hasil perhitungannya' , f_y ) . maka akan mendapatkan hasil seperti dibawah ini: iterasi ke - 1 eror = 1.0 hasil perhitungannya 1.0 iterasi ke - 2 eror = 8.0 hasil perhitungannya 9.0 iterasi ke - 3 eror = 32.0 hasil perhitungannya 41.0 iterasi ke - 4 eror = 85.33333333333333 hasil perhitungannya 126.33333333333333 iterasi ke - 5 eror = 170.66666666666669 hasil perhitungannya 297.0 iterasi ke - 6 eror = 273.0666666666666 hasil perhitungannya 570.0666666666666 iterasi ke - 7 eror = 364.08888888888896 hasil perhitungannya 934.1555555555556 iterasi ke - 8 eror = 416.1015873015872 hasil perhitungannya 1350.2571428571428 iterasi ke - 9 eror = 416.1015873015872 hasil perhitungannya 1766.35873015873 iterasi ke - 10 eror = 369.8680776014112 hasil perhitungannya 2136.226807760141 iterasi ke - 11 eror = 295.89446208112895 hasil perhitungannya 2432.12126984127 iterasi ke - 12 eror = 215.195972422639 hasil perhitungannya 2647.317242263909 iterasi ke - 13 eror = 143.46398161509296 hasil perhitungannya 2790.781223879002 iterasi ke - 14 eror = 88.28552714774924 hasil perhitungannya 2879.0667510267513 iterasi ke - 15 eror = 50.448872655856576 hasil perhitungannya 2929.515623682608 iterasi ke - 16 eror = 26.90606541645684 hasil perhitungannya 2956.4216890990647 iterasi ke - 17 eror = 13.45303270822842 hasil perhitungannya 2969.874721807293 iterasi ke - 18 eror = 6.330838921519444 hasil perhitungannya 2976.2055607288125 iterasi ke - 19 eror = 2.8137061873417224 hasil perhitungannya 2979.0192669161543 iterasi ke - 20 eror = 1.184718394670199 hasil perhitungannya 2980.2039853108245 iterasi ke - 21 eror = 0.47388735786807956 hasil perhitungannya 2980.6778726686925 iterasi ke - 22 eror = 0.18052851728316455 hasil perhitungannya 2980.8584011859757 iterasi ke - 23 eror = 0.06564673355751438 hasil perhitungannya 2980.924047919533 iterasi ke - 24 eror = 0.022833646454728296 hasil perhitungannya 2980.946881565988 iterasi ke - 25 eror = 0.0076112154847578495 hasil perhitungannya 2980.9544927814727 iterasi ke - 26 eror = 0.0024355889549951826 hasil perhitungannya 2980.9569283704277 iterasi ke - 27 eror = 0.0007494119863622473 hasil perhitungannya 2980.957677782414 . looping berhenti pada iterasi ke-27 karena eror < 0,001. Jadi dapat disimpulkan bahwa e^{2 x} e^{2 x} dengan x x = 4 dan ekspansi eror < 0,001 berhenti pada iterasi ke-27 dengan nilai eror 0,0007494119863622473. Sehingga e^8 e^8 = 2.980,9579870417282747\u202c dan e^{27} e^{27} = 2.980,957677782414 maka hasil komputasi mendapatkan nilai eror = 0,0007494119863622473","title":"Program Python"},{"location":"2metode/","text":"TUGAS 2 - Program Newton Raphson pada Fungsi Persamaan Non Linear \u00b6 Newton-Raphson \u00b6 Pengertian \u00b6 Newton-Raphson atau biasanya didefinisikan sebagai sebuah metode pencarian akar pada fungsi f(x) f(x) melalui pendekatan satu titik dengan fungsi f(x) f(x) yang memiliki turunan. Metode ini memakai pendekatan satu titik untuk titik awalnya. Oleh karena itu dianggap lebih mudah dari Bisection Method (Metode Bagi Dua). Convergen ke akar bisa semakin cepat dilakukan apabila titik awal yang dipilih dengan akar yang sebenarnya semakin dekat. Prosedur \u00b6 Untuk menentukan prosedur perlu menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus ( misal garis: imath imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis imath imath memotong sumbu x x di titik x_1 x_1 . Ulangi langkah sebelumnya dengan x_1 x_1 sebagai titik awalnya. Setelah beberapa kali perulangan maka akan mendapatkan titik x_2, x_3, x_4, ... , x_n x_2, x_3, x_4, ... , x_n dengan x_n x_n adalah bilangan ril yang merupakan akar atau mendekati akar yang sebenarnya. Atau bisa digambarkan seperti dibawah ini . . . Dari gambar diatas, maka kita bisa menurunkan rumus metode newton-raphson, sebagai berikut: persamaan garis imath: y - y_0 = m(x-x_0) imath: y - y_0 = m(x-x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis imath imath dengan sumbu -x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 y = 0 dan x = x_1 x = x_1 maka koordinat titik x_1, 0 x_1, 0 - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga didapatkan formula sebagai berikut: x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} . Algoritma \u00b6 Dari formula diatas, dapat disusun sebuah algoritma yang kemudian diimplementasikan menjadi sebuah program. Berikut adalah algoritma untuk menyusun akar - akar f(x) = 0 f(x) = 0 : Definisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) . Tentukan epsilon sebagai toleransi kesalahan serta iterasi maksimum untuk Stopping Condition . Pilih tebakan awal x_0 x_0 . Hitung f(x_0) f(x_0) dan f'(x_0) f'(x_0) . Hitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . Jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah 3. Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar. Jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4. Atau bisa juga menggunakan program python sebagai berikut. Program Python \u00b6 import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \" \\n iterasi ke = \" , iterasi , \" \\n x = \" , f_2 , \" \\n f(\" , f_2 , \") = \" , fungsi ( f_2 ), \" \\n selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) . Keterangan : Import Library math (matematika). Karena kita menggunakan contoh fungsi f(x) = e^x - 4x f(x) = e^x - 4x maka kita membuat sebuah fungsi yang sesuai, dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 . Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition . Mendeklarasikan iterasi = 0 untuk perulangan yang ke-0 dan akan ditambah setiap kali perulangan. Mendeklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan. Melakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon Menghitung x_b x_b dengan rumus yang sudah didapatkan sebelumnya. Melakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi. Jika pengecekan selisih > error bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke-n. . . output hasil : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 iterasi ke = 1 x = 0.3333333333333333 f( 0.3333333333333333 ) = 0.06227877883196098 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 iterasi ke = 2 x = 0.35724635301940616 f( 0.35724635301940616 ) = 0.0004022049593612742 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 iterasi ke = 3 x = 0.35740281572145605 f( 0.35740281572145605 ) = 1.734656973617632e-08 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 iterasi ke = 4 x = 0.3574028224700733 f( 0.3574028224700733 ) = -6.439293542825908e-15 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733","title":"2-Metode Newton-Raphson"},{"location":"2metode/#tugas-2-program-newton-raphson-pada-fungsi-persamaan-non-linear","text":"","title":"TUGAS 2 - Program Newton Raphson pada Fungsi Persamaan Non Linear"},{"location":"2metode/#newton-raphson","text":"","title":"Newton-Raphson"},{"location":"2metode/#pengertian","text":"Newton-Raphson atau biasanya didefinisikan sebagai sebuah metode pencarian akar pada fungsi f(x) f(x) melalui pendekatan satu titik dengan fungsi f(x) f(x) yang memiliki turunan. Metode ini memakai pendekatan satu titik untuk titik awalnya. Oleh karena itu dianggap lebih mudah dari Bisection Method (Metode Bagi Dua). Convergen ke akar bisa semakin cepat dilakukan apabila titik awal yang dipilih dengan akar yang sebenarnya semakin dekat.","title":"Pengertian"},{"location":"2metode/#prosedur","text":"Untuk menentukan prosedur perlu menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus ( misal garis: imath imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis imath imath memotong sumbu x x di titik x_1 x_1 . Ulangi langkah sebelumnya dengan x_1 x_1 sebagai titik awalnya. Setelah beberapa kali perulangan maka akan mendapatkan titik x_2, x_3, x_4, ... , x_n x_2, x_3, x_4, ... , x_n dengan x_n x_n adalah bilangan ril yang merupakan akar atau mendekati akar yang sebenarnya. Atau bisa digambarkan seperti dibawah ini . . . Dari gambar diatas, maka kita bisa menurunkan rumus metode newton-raphson, sebagai berikut: persamaan garis imath: y - y_0 = m(x-x_0) imath: y - y_0 = m(x-x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis imath imath dengan sumbu -x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 y = 0 dan x = x_1 x = x_1 maka koordinat titik x_1, 0 x_1, 0 - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga didapatkan formula sebagai berikut: x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} .","title":"Prosedur"},{"location":"2metode/#algoritma","text":"Dari formula diatas, dapat disusun sebuah algoritma yang kemudian diimplementasikan menjadi sebuah program. Berikut adalah algoritma untuk menyusun akar - akar f(x) = 0 f(x) = 0 : Definisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) . Tentukan epsilon sebagai toleransi kesalahan serta iterasi maksimum untuk Stopping Condition . Pilih tebakan awal x_0 x_0 . Hitung f(x_0) f(x_0) dan f'(x_0) f'(x_0) . Hitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . Jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah 3. Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar. Jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4. Atau bisa juga menggunakan program python sebagai berikut.","title":"Algoritma"},{"location":"2metode/#program-python","text":"import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \" \\n iterasi ke = \" , iterasi , \" \\n x = \" , f_2 , \" \\n f(\" , f_2 , \") = \" , fungsi ( f_2 ), \" \\n selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) . Keterangan : Import Library math (matematika). Karena kita menggunakan contoh fungsi f(x) = e^x - 4x f(x) = e^x - 4x maka kita membuat sebuah fungsi yang sesuai, dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 . Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition . Mendeklarasikan iterasi = 0 untuk perulangan yang ke-0 dan akan ditambah setiap kali perulangan. Mendeklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan. Melakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon Menghitung x_b x_b dengan rumus yang sudah didapatkan sebelumnya. Melakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi. Jika pengecekan selisih > error bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke-n. . . output hasil : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 iterasi ke = 1 x = 0.3333333333333333 f( 0.3333333333333333 ) = 0.06227877883196098 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 iterasi ke = 2 x = 0.35724635301940616 f( 0.35724635301940616 ) = 0.0004022049593612742 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 iterasi ke = 3 x = 0.35740281572145605 f( 0.35740281572145605 ) = 1.734656973617632e-08 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 iterasi ke = 4 x = 0.3574028224700733 f( 0.3574028224700733 ) = -6.439293542825908e-15 selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733","title":"Program Python"},{"location":"3eliminasi/","text":"TUGAS 3 - Metode Eliminasi Gauss, Gauss Jordan, Gauss Seidel, dan Iterasi Jacobi \u00b6 Eliminasi Gauss \u00b6 Eliminasi gauss metod merupakan salah satu cara untuk menyelesaikan persamaan linear secara langsung. Pokok pada metode eliminasi gauss ini yaitu dengan menjadikan persamaan menjadi bentuk matriks dan menyederhanakan matriks tersebut kedalam bentuk segitiga atas. Kemudian bentuk matriks tersebut disubstitusi balik untuk memperoleh nilai akar persamaannya. . Kelebihan menggunakan eliminasi gauss: dapat menentukan sistem konsisten dapat menghilangkan kebutuhan untuk menulis ulang variabel. lebih mudah dipecahkan. minimnya error. Kekurangannya: minimnya akurasi saat pembulatan desimal. . Contoh: Selesaikan SPL berikut: (1) 2 x_{1}+x_{2}+4 x_{3}=16 2 x_{1}+x_{2}+4 x_{3}=16 (2) 3 x_{1}+2 x_{2}+x_{3}=10 3 x_{1}+2 x_{2}+x_{3}=10 (3) x_{1}+3 x_{2}+3 x_{3}=16 x_{1}+3 x_{2}+3 x_{3}=16 . Jawab: dalam bentuk matriks: \\left(\\begin{array}{lll|l} 2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16 \\end{array}\\right) \\left(\\begin{array}{lll|l} 2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16 \\end{array}\\right) Penyelesaian: Eliminasi Gauss \\left(\\begin{array}{lll|l}2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) b_{2}-b_{1}\\left(\\begin{array}{ccc|c}2 & 1 & 4 & 16 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) \\left(\\begin{array}{lll|l}2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) b_{2}-b_{1}\\left(\\begin{array}{ccc|c}2 & 1 & 4 & 16 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) . . langkah-langkah . langkah (1) b_{1}\\left(\\frac{1}{2}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) b_{1}\\left(\\frac{1}{2}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) langkah (2) b_{2}-b_{1} b_{2}-b_{1} b_{3}-b_{1}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & \\frac{1}{2} & -5 & -14 \\\\ 0 & \\frac{5}{2} & 1 & 8\\end{array}\\right) b_{3}-b_{1}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & \\frac{1}{2} & -5 & -14 \\\\ 0 & \\frac{5}{2} & 1 & 8\\end{array}\\right) langkah (3) b_{3}-b_{2} b_{2}(2)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 2 & 6 & 22\\end{array}\\right) b_{3}-b_{2} b_{2}(2)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 2 & 6 & 22\\end{array}\\right) langkah (4) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 1 & 16 & 50\\end{array}\\right) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 1 & 16 & 50\\end{array}\\right) langkah (5) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 26 & 78\\end{array}\\right) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 26 & 78\\end{array}\\right) langkah (6) b_{3}\\left(\\frac{1}{26}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 1 & 3\\end{array}\\right) b_{3}\\left(\\frac{1}{26}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 1 & 3\\end{array}\\right) langkah (7) Dengan demikian diperoleh: x_{1}+\\frac{1}{2} x_{2}+2 x_{3}=8 \\ldots \\ldots \\ldots \\ldots \\ldots(1) x_{1}+\\frac{1}{2} x_{2}+2 x_{3}=8 \\ldots \\ldots \\ldots \\ldots \\ldots(1) x_{2}-10 x_{3}=-28\\ldots \\ldots \\ldots \\ldots \\ldots(2) x_{2}-10 x_{3}=-28\\ldots \\ldots \\ldots \\ldots \\ldots(2) x_{3}=3\\ldots \\ldots \\ldots \\ldots \\ldots(3) x_{3}=3\\ldots \\ldots \\ldots \\ldots \\ldots(3) Untuk memperoleh x_{1} x_{1} dan x_{2} x_{2} subt pers (3) ke pers. (1) dan (2), x_{3}=3 x_{3}=3 x_{2}-10(3)=-28 x_{2}-10(3)=-28 x_{2}-30=-28 x_{2}-30=-28 x_{2}=2 x_{2}=2 Untuk memperoleh x_{1} x_{1} x_{1}+\\frac{1}{2}(2)+2(3)=8 x_{1}+\\frac{1}{2}(2)+2(3)=8 x_{1}+1+6=8 x_{1}+1+6=8 x_{1}=1 x_{1}=1 Jadi diperoleh x_{1}=1, x_{2}=2 \\operatorname{dan} x_{3}=3 x_{1}=1, x_{2}=2 \\operatorname{dan} x_{3}=3 . . Gauss Jordan \u00b6 Metode ini merupakan pengembangan dari eliminasi gauss. Bedanya pada augmented matriks, dimana sebelah kiri dirubah menjadi matriks diagonal. \\left[\\begin{array}{cccccc} a_{11} & a_{12} & a_{13} & \\dots & a_{1 n} & b_{1} \\\\ a_{21} & a_{22} & a_{23} & \\dots & a_{2 n} & b_{2} \\\\ a_{31} & a_{32} & a_{33} & \\dots & a_{3 n} & b_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ a_{n 1} & a_{n 2} & a_{n 3} & \\dots & a_{n n} & b_{n} \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccccc} 1 & 0 & 0 & \\dots & 0 & d_{1} \\\\ 0 & 1 & 0 & \\dots & 0 & d_{2} \\\\ 0 & 0 & 1 & \\dots & 0 & d_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & \\dots & 1 & d_{n} \\end{array}\\right] \\left[\\begin{array}{cccccc} a_{11} & a_{12} & a_{13} & \\dots & a_{1 n} & b_{1} \\\\ a_{21} & a_{22} & a_{23} & \\dots & a_{2 n} & b_{2} \\\\ a_{31} & a_{32} & a_{33} & \\dots & a_{3 n} & b_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ a_{n 1} & a_{n 2} & a_{n 3} & \\dots & a_{n n} & b_{n} \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccccc} 1 & 0 & 0 & \\dots & 0 & d_{1} \\\\ 0 & 1 & 0 & \\dots & 0 & d_{2} \\\\ 0 & 0 & 1 & \\dots & 0 & d_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & \\dots & 1 & d_{n} \\end{array}\\right] Adapun algoritma yang digunakan pada metode eliminasi gauss jordan, sebagai berikut: . (1) Masukkan matrik A, dan vektor B beserta ukurannya n (2) Buat augmented matrik [A/B] namakan dengan A (3) Untuk baris ke i i dimana i i =1 s/d n n (3a) Perhatikan apakah nilai a_{i, i} a_{i, i} sama dengan nol: Bila ya: pertukarkan baris ke i i dan baris ke i+k \\leq n i+k \\leq n , dimana a_{i+k, i} a_{i+k, i} tidak sama dengan nol, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. Bila tidak : lanjutkan (3b) Jadikan nilai diagonalnya menjadi satu, dengan cara untuk setiap kolom k k dimana {k}=1 {k}=1 s/d n+1, hitung a_{i, k}=\\frac{a_{i, k}}{a_{i, j}} a_{i, k}=\\frac{a_{i, k}}{a_{i, j}} (4) Untuk baris ke j, dimana j =i+1 s/d n Lakukan operasi baris elementer: untuk kolom k dimana k=1 s/d n Hitung c=a_{j, i} c=a_{j, i} _ Hitung a_{j, k}=a_{j, k}-c . a_{i, k} a_{j, k}=a_{j, k}-c . a_{i, k} _ (5) Penyelesaian, untuk i= n s/d 1 (bergerak dari baris ke n sampai baris pertama) x_{i}=a_{i, n+1} x_{i}=a_{i, n+1} . listing program import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) . output hasil: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 Sehingga dapat disimpulkan untuk panjang matriks program diatas ada 3 variabel, dan menghasilkan nilai Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 . . Gauss Seidel \u00b6 Eliminasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah. Bila diketahui persamaan linier simultan: a_{11} x_{1}+a_{12} x_{2}+\\dots+a_{1 n} x_{n}=b_{1} a_{11} x_{1}+a_{12} x_{2}+\\dots+a_{1 n} x_{n}=b_{1} a_{21} x_{1}+a_{22} x_{2}+\\dots+a_{2 n} x_{n}=b_{2} a_{21} x_{1}+a_{22} x_{2}+\\dots+a_{2 n} x_{n}=b_{2} a_{n 1} x_{1}+a_{n 2} x_{2}+\\dots+a_{n n} x_{n}=b_{n} a_{n 1} x_{1}+a_{n 2} x_{2}+\\dots+a_{n n} x_{n}=b_{n} Berikan nilai awal dari setiap x_{i}(i=1 \\cdots n) x_{i}(i=1 \\cdots n) kemudian sistem persamaan linier tersebut akan menjadi : x_{1}=\\frac{1}{a_{11}}\\left(b_{1}-a_{12} x_{2}-a_{13} x_{3}-\\cdots-a_{1 n} x_{n}\\right) x_{1}=\\frac{1}{a_{11}}\\left(b_{1}-a_{12} x_{2}-a_{13} x_{3}-\\cdots-a_{1 n} x_{n}\\right) x_{2}=\\frac{1}{a_{22}}\\left(b_{2}-a_{21} x_{2}-a_{23} x_{3}-\\dots-a_{2 n} x_{n}\\right) x_{2}=\\frac{1}{a_{22}}\\left(b_{2}-a_{21} x_{2}-a_{23} x_{3}-\\dots-a_{2 n} x_{n}\\right) x_{n}=\\frac{1}{a_{m n}}\\left(b_{n}-a_{n 1} x_{1}-a_{n 2} x_{2}-\\cdots-a_{m-1} x_{n-1}\\right) x_{n}=\\frac{1}{a_{m n}}\\left(b_{n}-a_{n 1} x_{1}-a_{n 2} x_{2}-\\cdots-a_{m-1} x_{n-1}\\right) Listing program: def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) . . output hasil : Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] . . Iterasi Jacobi \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. listing program: from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) . output hasil: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"3-Eliminasi Gauss"},{"location":"3eliminasi/#tugas-3-metode-eliminasi-gauss-gauss-jordan-gauss-seidel-dan-iterasi-jacobi","text":"","title":"TUGAS 3 - Metode Eliminasi Gauss, Gauss Jordan, Gauss Seidel, dan Iterasi Jacobi"},{"location":"3eliminasi/#eliminasi-gauss","text":"Eliminasi gauss metod merupakan salah satu cara untuk menyelesaikan persamaan linear secara langsung. Pokok pada metode eliminasi gauss ini yaitu dengan menjadikan persamaan menjadi bentuk matriks dan menyederhanakan matriks tersebut kedalam bentuk segitiga atas. Kemudian bentuk matriks tersebut disubstitusi balik untuk memperoleh nilai akar persamaannya. . Kelebihan menggunakan eliminasi gauss: dapat menentukan sistem konsisten dapat menghilangkan kebutuhan untuk menulis ulang variabel. lebih mudah dipecahkan. minimnya error. Kekurangannya: minimnya akurasi saat pembulatan desimal. . Contoh: Selesaikan SPL berikut: (1) 2 x_{1}+x_{2}+4 x_{3}=16 2 x_{1}+x_{2}+4 x_{3}=16 (2) 3 x_{1}+2 x_{2}+x_{3}=10 3 x_{1}+2 x_{2}+x_{3}=10 (3) x_{1}+3 x_{2}+3 x_{3}=16 x_{1}+3 x_{2}+3 x_{3}=16 . Jawab: dalam bentuk matriks: \\left(\\begin{array}{lll|l} 2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16 \\end{array}\\right) \\left(\\begin{array}{lll|l} 2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16 \\end{array}\\right) Penyelesaian: Eliminasi Gauss \\left(\\begin{array}{lll|l}2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) b_{2}-b_{1}\\left(\\begin{array}{ccc|c}2 & 1 & 4 & 16 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) \\left(\\begin{array}{lll|l}2 & 1 & 4 & 16 \\\\ 3 & 2 & 1 & 10 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) b_{2}-b_{1}\\left(\\begin{array}{ccc|c}2 & 1 & 4 & 16 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) . . langkah-langkah . langkah (1) b_{1}\\left(\\frac{1}{2}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) b_{1}\\left(\\frac{1}{2}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 1 & 1 & -3 & -6 \\\\ 1 & 3 & 3 & 16\\end{array}\\right) langkah (2) b_{2}-b_{1} b_{2}-b_{1} b_{3}-b_{1}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & \\frac{1}{2} & -5 & -14 \\\\ 0 & \\frac{5}{2} & 1 & 8\\end{array}\\right) b_{3}-b_{1}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & \\frac{1}{2} & -5 & -14 \\\\ 0 & \\frac{5}{2} & 1 & 8\\end{array}\\right) langkah (3) b_{3}-b_{2} b_{2}(2)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 2 & 6 & 22\\end{array}\\right) b_{3}-b_{2} b_{2}(2)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 2 & 6 & 22\\end{array}\\right) langkah (4) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 1 & 16 & 50\\end{array}\\right) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 1 & 16 & 50\\end{array}\\right) langkah (5) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 26 & 78\\end{array}\\right) b_{3}-b_{2}\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 26 & 78\\end{array}\\right) langkah (6) b_{3}\\left(\\frac{1}{26}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 1 & 3\\end{array}\\right) b_{3}\\left(\\frac{1}{26}\\right)\\left(\\begin{array}{ccc|c}1 & \\frac{1}{2} & 2 & 8 \\\\ 0 & 1 & -10 & -28 \\\\ 0 & 0 & 1 & 3\\end{array}\\right) langkah (7) Dengan demikian diperoleh: x_{1}+\\frac{1}{2} x_{2}+2 x_{3}=8 \\ldots \\ldots \\ldots \\ldots \\ldots(1) x_{1}+\\frac{1}{2} x_{2}+2 x_{3}=8 \\ldots \\ldots \\ldots \\ldots \\ldots(1) x_{2}-10 x_{3}=-28\\ldots \\ldots \\ldots \\ldots \\ldots(2) x_{2}-10 x_{3}=-28\\ldots \\ldots \\ldots \\ldots \\ldots(2) x_{3}=3\\ldots \\ldots \\ldots \\ldots \\ldots(3) x_{3}=3\\ldots \\ldots \\ldots \\ldots \\ldots(3) Untuk memperoleh x_{1} x_{1} dan x_{2} x_{2} subt pers (3) ke pers. (1) dan (2), x_{3}=3 x_{3}=3 x_{2}-10(3)=-28 x_{2}-10(3)=-28 x_{2}-30=-28 x_{2}-30=-28 x_{2}=2 x_{2}=2 Untuk memperoleh x_{1} x_{1} x_{1}+\\frac{1}{2}(2)+2(3)=8 x_{1}+\\frac{1}{2}(2)+2(3)=8 x_{1}+1+6=8 x_{1}+1+6=8 x_{1}=1 x_{1}=1 Jadi diperoleh x_{1}=1, x_{2}=2 \\operatorname{dan} x_{3}=3 x_{1}=1, x_{2}=2 \\operatorname{dan} x_{3}=3 . .","title":"Eliminasi Gauss"},{"location":"3eliminasi/#gauss-jordan","text":"Metode ini merupakan pengembangan dari eliminasi gauss. Bedanya pada augmented matriks, dimana sebelah kiri dirubah menjadi matriks diagonal. \\left[\\begin{array}{cccccc} a_{11} & a_{12} & a_{13} & \\dots & a_{1 n} & b_{1} \\\\ a_{21} & a_{22} & a_{23} & \\dots & a_{2 n} & b_{2} \\\\ a_{31} & a_{32} & a_{33} & \\dots & a_{3 n} & b_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ a_{n 1} & a_{n 2} & a_{n 3} & \\dots & a_{n n} & b_{n} \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccccc} 1 & 0 & 0 & \\dots & 0 & d_{1} \\\\ 0 & 1 & 0 & \\dots & 0 & d_{2} \\\\ 0 & 0 & 1 & \\dots & 0 & d_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & \\dots & 1 & d_{n} \\end{array}\\right] \\left[\\begin{array}{cccccc} a_{11} & a_{12} & a_{13} & \\dots & a_{1 n} & b_{1} \\\\ a_{21} & a_{22} & a_{23} & \\dots & a_{2 n} & b_{2} \\\\ a_{31} & a_{32} & a_{33} & \\dots & a_{3 n} & b_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ a_{n 1} & a_{n 2} & a_{n 3} & \\dots & a_{n n} & b_{n} \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccccc} 1 & 0 & 0 & \\dots & 0 & d_{1} \\\\ 0 & 1 & 0 & \\dots & 0 & d_{2} \\\\ 0 & 0 & 1 & \\dots & 0 & d_{3} \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & \\dots & 1 & d_{n} \\end{array}\\right] Adapun algoritma yang digunakan pada metode eliminasi gauss jordan, sebagai berikut: . (1) Masukkan matrik A, dan vektor B beserta ukurannya n (2) Buat augmented matrik [A/B] namakan dengan A (3) Untuk baris ke i i dimana i i =1 s/d n n (3a) Perhatikan apakah nilai a_{i, i} a_{i, i} sama dengan nol: Bila ya: pertukarkan baris ke i i dan baris ke i+k \\leq n i+k \\leq n , dimana a_{i+k, i} a_{i+k, i} tidak sama dengan nol, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. Bila tidak : lanjutkan (3b) Jadikan nilai diagonalnya menjadi satu, dengan cara untuk setiap kolom k k dimana {k}=1 {k}=1 s/d n+1, hitung a_{i, k}=\\frac{a_{i, k}}{a_{i, j}} a_{i, k}=\\frac{a_{i, k}}{a_{i, j}} (4) Untuk baris ke j, dimana j =i+1 s/d n Lakukan operasi baris elementer: untuk kolom k dimana k=1 s/d n Hitung c=a_{j, i} c=a_{j, i} _ Hitung a_{j, k}=a_{j, k}-c . a_{i, k} a_{j, k}=a_{j, k}-c . a_{i, k} _ (5) Penyelesaian, untuk i= n s/d 1 (bergerak dari baris ke n sampai baris pertama) x_{i}=a_{i, n+1} x_{i}=a_{i, n+1} . listing program import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) . output hasil: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 Sehingga dapat disimpulkan untuk panjang matriks program diatas ada 3 variabel, dan menghasilkan nilai Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 . .","title":"Gauss Jordan"},{"location":"3eliminasi/#gauss-seidel","text":"Eliminasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah. Bila diketahui persamaan linier simultan: a_{11} x_{1}+a_{12} x_{2}+\\dots+a_{1 n} x_{n}=b_{1} a_{11} x_{1}+a_{12} x_{2}+\\dots+a_{1 n} x_{n}=b_{1} a_{21} x_{1}+a_{22} x_{2}+\\dots+a_{2 n} x_{n}=b_{2} a_{21} x_{1}+a_{22} x_{2}+\\dots+a_{2 n} x_{n}=b_{2} a_{n 1} x_{1}+a_{n 2} x_{2}+\\dots+a_{n n} x_{n}=b_{n} a_{n 1} x_{1}+a_{n 2} x_{2}+\\dots+a_{n n} x_{n}=b_{n} Berikan nilai awal dari setiap x_{i}(i=1 \\cdots n) x_{i}(i=1 \\cdots n) kemudian sistem persamaan linier tersebut akan menjadi : x_{1}=\\frac{1}{a_{11}}\\left(b_{1}-a_{12} x_{2}-a_{13} x_{3}-\\cdots-a_{1 n} x_{n}\\right) x_{1}=\\frac{1}{a_{11}}\\left(b_{1}-a_{12} x_{2}-a_{13} x_{3}-\\cdots-a_{1 n} x_{n}\\right) x_{2}=\\frac{1}{a_{22}}\\left(b_{2}-a_{21} x_{2}-a_{23} x_{3}-\\dots-a_{2 n} x_{n}\\right) x_{2}=\\frac{1}{a_{22}}\\left(b_{2}-a_{21} x_{2}-a_{23} x_{3}-\\dots-a_{2 n} x_{n}\\right) x_{n}=\\frac{1}{a_{m n}}\\left(b_{n}-a_{n 1} x_{1}-a_{n 2} x_{2}-\\cdots-a_{m-1} x_{n-1}\\right) x_{n}=\\frac{1}{a_{m n}}\\left(b_{n}-a_{n 1} x_{1}-a_{n 2} x_{2}-\\cdots-a_{m-1} x_{n-1}\\right) Listing program: def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) . . output hasil : Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] . .","title":"Gauss Seidel"},{"location":"3eliminasi/#iterasi-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. listing program: from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) . output hasil: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Iterasi Jacobi"},{"location":"4recursive/","text":"TUGAS 4 - Recursive Trapezoid \u00b6 Deskripsi \u00b6 Recursive Trapezoid (ind: trapesium rekursif) merupakan sebuah metod atau cara numerik yang terintegrasi berdasarkan pada jumlah para segmen yang berbentuk trapesium. Suatu integral apabila didekati menggunakan trapesium metod menggunakan sebuah segmen saja, maka didapatkan persamaan seperti berikut: \\int_{a}^{b} f(x) d x=\\frac{b-a}{2}[f(a)+f(b)]+E \\int_{a}^{b} f(x) d x=\\frac{b-a}{2}[f(a)+f(b)]+E dan bisa juga digambarkan suatu estimasi berdasar intervalnya: . Algoritma \u00b6 Dari formula diatas, dapat disusun sebuah algoritma yang kemudian diimplementasikan menjadi sebuah program. Berikut adalah algoritma untuk integral trapezoid : Definisikan y = f(x). Tentukan batas integrasi. Misal a: untuk batas bawah, dan b: untuk batas atas. Tentukan n: jumlah pembagi. Hitung selisih batas dibagi 2. (b-a)/2=h Hitung L=\\frac{h}{2}\\left(f_{0}+2 \\sum_{i=1}^{n-1} f_{i}+f_{n}\\right) L=\\frac{h}{2}\\left(f_{0}+2 \\sum_{i=1}^{n-1} f_{i}+f_{n}\\right) Atau bisa juga menggunakan program python sebagai berikut. Program Python \u00b6 #definisi fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \"fungsi yang digunakan adalah\" ) print ( \"\" ) print ( \" \\t\\t \" , \"f(x) = 1/(1+x)\" ) print ( \"\" ) a = float ( input ( \"masukkan batas bawah integral : \" )) b = float ( input ( \"masukkan batas atas integral : \" )) c = int ( input ( \"masukkan n : \" )) eror = [] print ( \"\" ) print ( \"----------------Hasil Integrasi-----------------\" ) print ( \"iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trap = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 eror . append ( trap ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trap ) print ( eror [ iterasi - 1 ]) print ( eror [ iterasi ]) hasil = ( eror [ iterasi - 1 ] - eror [ iterasi ]) print ( hasil ) print ( \"estimasi error : \" + str ( hasil )) . . output hasil :","title":"4-Recursive Trapezoid"},{"location":"4recursive/#tugas-4-recursive-trapezoid","text":"","title":"TUGAS 4 - Recursive Trapezoid"},{"location":"4recursive/#deskripsi","text":"Recursive Trapezoid (ind: trapesium rekursif) merupakan sebuah metod atau cara numerik yang terintegrasi berdasarkan pada jumlah para segmen yang berbentuk trapesium. Suatu integral apabila didekati menggunakan trapesium metod menggunakan sebuah segmen saja, maka didapatkan persamaan seperti berikut: \\int_{a}^{b} f(x) d x=\\frac{b-a}{2}[f(a)+f(b)]+E \\int_{a}^{b} f(x) d x=\\frac{b-a}{2}[f(a)+f(b)]+E dan bisa juga digambarkan suatu estimasi berdasar intervalnya: .","title":"Deskripsi"},{"location":"4recursive/#algoritma","text":"Dari formula diatas, dapat disusun sebuah algoritma yang kemudian diimplementasikan menjadi sebuah program. Berikut adalah algoritma untuk integral trapezoid : Definisikan y = f(x). Tentukan batas integrasi. Misal a: untuk batas bawah, dan b: untuk batas atas. Tentukan n: jumlah pembagi. Hitung selisih batas dibagi 2. (b-a)/2=h Hitung L=\\frac{h}{2}\\left(f_{0}+2 \\sum_{i=1}^{n-1} f_{i}+f_{n}\\right) L=\\frac{h}{2}\\left(f_{0}+2 \\sum_{i=1}^{n-1} f_{i}+f_{n}\\right) Atau bisa juga menggunakan program python sebagai berikut.","title":"Algoritma"},{"location":"4recursive/#program-python","text":"#definisi fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \"fungsi yang digunakan adalah\" ) print ( \"\" ) print ( \" \\t\\t \" , \"f(x) = 1/(1+x)\" ) print ( \"\" ) a = float ( input ( \"masukkan batas bawah integral : \" )) b = float ( input ( \"masukkan batas atas integral : \" )) c = int ( input ( \"masukkan n : \" )) eror = [] print ( \"\" ) print ( \"----------------Hasil Integrasi-----------------\" ) print ( \"iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trap = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 eror . append ( trap ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trap ) print ( eror [ iterasi - 1 ]) print ( eror [ iterasi ]) hasil = ( eror [ iterasi - 1 ] - eror [ iterasi ]) print ( hasil ) print ( \"estimasi error : \" + str ( hasil )) . . output hasil :","title":"Program Python"},{"location":"5rex/","text":"TUGAS 5 - Richardson Extrapolation \u00b6 Deskripsi \u00b6 Richardson Extrapolation adalah sebuah metod/cara percepatan urutan yang tujuan penggunaannya untuk meningkatkan laju konvergensi sebuah urutan. Atau bisa juga diartikan sebagai penggabungan dua nilai perkiraan yang dihitung dengan menggunakan rumus yang sama guna memperoleh metode orde tinggi yang lebih dekat dengan perkiraan jumlah tertentu. Metod ini termasuk integrasi Romberg , yang menerapkan ekstrapolasi richard pada aturan trapesium dan algoritma Bulirsch-Tur guna menyelesaikan suatu persamaan diferensi biasa. Formula \u00b6 \\frac{f(x+h)-f(x-h)}{(2 h)} \\frac{f(x+h)-f(x-h)}{(2 h)} Pada Richardson Extrapolation ditetapkan f(x) f(x) dan x x tertentu, sehingga dapat berbentuk tabel seperti berikut; Tabel Richardson Extrapolation D(0,0)=\\varnothing(h) D(0,0)=\\varnothing(h) D(0,0)=\\varnothing(h / 2) \\quad \\quad D(1,1) D(0,0)=\\varnothing(h / 2) \\quad \\quad D(1,1) D(0,0)=\\varnothing(h / 4) \\quad \\quad D(2,1) \\quad D(2,2) D(0,0)=\\varnothing(h / 4) \\quad \\quad D(2,1) \\quad D(2,2) D(0,0)=\\varnothing(h / 8) \\quad \\quad D(3,1) \\quad D(3,1) \\quad D(3,3) D(0,0)=\\varnothing(h / 8) \\quad \\quad D(3,1) \\quad D(3,1) \\quad D(3,3) Perhitungan dengan Richardson Extrapolation \u00b6 Hitung terlebih dahulu nilai numerik dari turunan f(x)=x^{\\cos (x)} f(x)=x^{\\cos (x)} , x = 0.5 x = 0.5 dan dimulai dari h{1} = 0.5 h{1} = 0.5 dan h{2} = 0.25 h{2} = 0.25 \\begin{aligned} &D(0,0)=\\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2 h}\\\\ &D(1,0)=\\varnothing(0.1)=\\frac{f(0.7)-f(0.5)}{0.2}=1.08483\\\\ &D(2,0)=\\varnothing(0.05)=\\frac{f(0.65)-f(0.55)}{0.2}=1.08988\\\\ &D(3,0)=\\varnothing(0.025)=\\frac{f(0.625)-f(0.575)}{0.05}=1.09115 \\end{aligned} \\begin{aligned} &D(0,0)=\\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2 h}\\\\ &D(1,0)=\\varnothing(0.1)=\\frac{f(0.7)-f(0.5)}{0.2}=1.08483\\\\ &D(2,0)=\\varnothing(0.05)=\\frac{f(0.65)-f(0.55)}{0.2}=1.08988\\\\ &D(3,0)=\\varnothing(0.025)=\\frac{f(0.625)-f(0.575)}{0.05}=1.09115 \\end{aligned} Lalu untuk D(n,m), m \\neq 0 D(n,m), m \\neq 0 atau dapat dihitung dengan cara berikut; \\begin{aligned} &D(n, m)=\\frac{4^{m}}{4^{m}-1} D(n, m-1)-\\frac{1}{4^{m}-1} D(n-1, m-1)\\\\ &D(1,1)=\\frac{4}{3} D(1,0)-\\frac{1}{3} D(0,0)=1.09156\\\\ &D(2,1)=\\frac{4}{3} D(2,0)-\\frac{1}{3} D(1,0)=1.09157\\\\ &D(2,2)=\\frac{16}{15} D(2,1)-\\frac{1}{15} D(1,1)=1.09157 \\end{aligned} \\begin{aligned} &D(n, m)=\\frac{4^{m}}{4^{m}-1} D(n, m-1)-\\frac{1}{4^{m}-1} D(n-1, m-1)\\\\ &D(1,1)=\\frac{4}{3} D(1,0)-\\frac{1}{3} D(0,0)=1.09156\\\\ &D(2,1)=\\frac{4}{3} D(2,0)-\\frac{1}{3} D(1,0)=1.09157\\\\ &D(2,2)=\\frac{16}{15} D(2,1)-\\frac{1}{15} D(1,1)=1.09157 \\end{aligned} Dari hasil diatas kemudian akan mendapatkan hasil nilai yang bisa kita masukkan dalam tabel Richardson, seperti ini; Tabel Richardson Extrapolation 1,08483 1,08988 \\quad \\quad \\quad \\quad 1,09156 1,09115 \\quad \\quad \\quad \\quad 1,09157 \\quad \\quad 1,09157 Sehingga dapat disimpulkan bahwa pada baris ketiga kolom ke-3 diatas adalah hasil estimasi terbaik turunan suatu fungsi f(x)=x^{\\cos (x)} f(x)=x^{\\cos (x)} pada x=0.6 x=0.6 yaitu 1,09157 . Atau bisa juga menggunakan program python sebagai berikut. Program Python \u00b6 import math from numpy import zeros def Oh ( x , h ): return ( f ( x + h ) - f ( x - h )) / ( 2 * h ) def richardson_extrapolation ( f , x , h , n ): D = zeros (( n + 1 , n + 1 )) for i in range ( n + 1 ): for j in range ( i + 1 ): if j == 0 : D [ i , 0 ] = round ( Oh ( x , h / ( 2 ** i )), 5 ) else : D [ i , j ] = round ((( 4 ** j ) / (( 4 ** j ) - 1 ) * D [ i , j - 1 ]) - ( 1 / (( 4 ** j ) - 1 ) * D [ i - 1 , j - 1 ]), 5 ) print ( D [ i , 0 : i + 1 ]) return D def f ( x ): return x ** math . cos ( x ) x = 0.6 h = 0.1 n = 2 print ( '=Tabel Richardson= \\n ' ) print ( 'f(x) = x^cos(x) \\n ' ) hasil = richardson_extrapolation ( f , x , h , n ) print ( 'hasil estimasi terbaik adalah' , hasil [ n , n ]) output hasil : = Tabel Richardson = f ( x ) = x ^ cos ( x ) [ 1.08483 ] [ 1.08988 1.09156 ] [ 1.09115 1.09157 1.09157 ] hasil estimasi terbaik adalah 1.09157","title":"5-Richardson Extrapolation"},{"location":"5rex/#tugas-5-richardson-extrapolation","text":"","title":"TUGAS 5 - Richardson Extrapolation"},{"location":"5rex/#deskripsi","text":"Richardson Extrapolation adalah sebuah metod/cara percepatan urutan yang tujuan penggunaannya untuk meningkatkan laju konvergensi sebuah urutan. Atau bisa juga diartikan sebagai penggabungan dua nilai perkiraan yang dihitung dengan menggunakan rumus yang sama guna memperoleh metode orde tinggi yang lebih dekat dengan perkiraan jumlah tertentu. Metod ini termasuk integrasi Romberg , yang menerapkan ekstrapolasi richard pada aturan trapesium dan algoritma Bulirsch-Tur guna menyelesaikan suatu persamaan diferensi biasa.","title":"Deskripsi"},{"location":"5rex/#formula","text":"\\frac{f(x+h)-f(x-h)}{(2 h)} \\frac{f(x+h)-f(x-h)}{(2 h)} Pada Richardson Extrapolation ditetapkan f(x) f(x) dan x x tertentu, sehingga dapat berbentuk tabel seperti berikut; Tabel Richardson Extrapolation D(0,0)=\\varnothing(h) D(0,0)=\\varnothing(h) D(0,0)=\\varnothing(h / 2) \\quad \\quad D(1,1) D(0,0)=\\varnothing(h / 2) \\quad \\quad D(1,1) D(0,0)=\\varnothing(h / 4) \\quad \\quad D(2,1) \\quad D(2,2) D(0,0)=\\varnothing(h / 4) \\quad \\quad D(2,1) \\quad D(2,2) D(0,0)=\\varnothing(h / 8) \\quad \\quad D(3,1) \\quad D(3,1) \\quad D(3,3) D(0,0)=\\varnothing(h / 8) \\quad \\quad D(3,1) \\quad D(3,1) \\quad D(3,3)","title":"Formula"},{"location":"5rex/#perhitungan-dengan-richardson-extrapolation","text":"Hitung terlebih dahulu nilai numerik dari turunan f(x)=x^{\\cos (x)} f(x)=x^{\\cos (x)} , x = 0.5 x = 0.5 dan dimulai dari h{1} = 0.5 h{1} = 0.5 dan h{2} = 0.25 h{2} = 0.25 \\begin{aligned} &D(0,0)=\\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2 h}\\\\ &D(1,0)=\\varnothing(0.1)=\\frac{f(0.7)-f(0.5)}{0.2}=1.08483\\\\ &D(2,0)=\\varnothing(0.05)=\\frac{f(0.65)-f(0.55)}{0.2}=1.08988\\\\ &D(3,0)=\\varnothing(0.025)=\\frac{f(0.625)-f(0.575)}{0.05}=1.09115 \\end{aligned} \\begin{aligned} &D(0,0)=\\varnothing(h)=\\frac{f(x+h)-f(x-h)}{2 h}\\\\ &D(1,0)=\\varnothing(0.1)=\\frac{f(0.7)-f(0.5)}{0.2}=1.08483\\\\ &D(2,0)=\\varnothing(0.05)=\\frac{f(0.65)-f(0.55)}{0.2}=1.08988\\\\ &D(3,0)=\\varnothing(0.025)=\\frac{f(0.625)-f(0.575)}{0.05}=1.09115 \\end{aligned} Lalu untuk D(n,m), m \\neq 0 D(n,m), m \\neq 0 atau dapat dihitung dengan cara berikut; \\begin{aligned} &D(n, m)=\\frac{4^{m}}{4^{m}-1} D(n, m-1)-\\frac{1}{4^{m}-1} D(n-1, m-1)\\\\ &D(1,1)=\\frac{4}{3} D(1,0)-\\frac{1}{3} D(0,0)=1.09156\\\\ &D(2,1)=\\frac{4}{3} D(2,0)-\\frac{1}{3} D(1,0)=1.09157\\\\ &D(2,2)=\\frac{16}{15} D(2,1)-\\frac{1}{15} D(1,1)=1.09157 \\end{aligned} \\begin{aligned} &D(n, m)=\\frac{4^{m}}{4^{m}-1} D(n, m-1)-\\frac{1}{4^{m}-1} D(n-1, m-1)\\\\ &D(1,1)=\\frac{4}{3} D(1,0)-\\frac{1}{3} D(0,0)=1.09156\\\\ &D(2,1)=\\frac{4}{3} D(2,0)-\\frac{1}{3} D(1,0)=1.09157\\\\ &D(2,2)=\\frac{16}{15} D(2,1)-\\frac{1}{15} D(1,1)=1.09157 \\end{aligned} Dari hasil diatas kemudian akan mendapatkan hasil nilai yang bisa kita masukkan dalam tabel Richardson, seperti ini; Tabel Richardson Extrapolation 1,08483 1,08988 \\quad \\quad \\quad \\quad 1,09156 1,09115 \\quad \\quad \\quad \\quad 1,09157 \\quad \\quad 1,09157 Sehingga dapat disimpulkan bahwa pada baris ketiga kolom ke-3 diatas adalah hasil estimasi terbaik turunan suatu fungsi f(x)=x^{\\cos (x)} f(x)=x^{\\cos (x)} pada x=0.6 x=0.6 yaitu 1,09157 . Atau bisa juga menggunakan program python sebagai berikut.","title":"Perhitungan dengan Richardson Extrapolation"},{"location":"5rex/#program-python","text":"import math from numpy import zeros def Oh ( x , h ): return ( f ( x + h ) - f ( x - h )) / ( 2 * h ) def richardson_extrapolation ( f , x , h , n ): D = zeros (( n + 1 , n + 1 )) for i in range ( n + 1 ): for j in range ( i + 1 ): if j == 0 : D [ i , 0 ] = round ( Oh ( x , h / ( 2 ** i )), 5 ) else : D [ i , j ] = round ((( 4 ** j ) / (( 4 ** j ) - 1 ) * D [ i , j - 1 ]) - ( 1 / (( 4 ** j ) - 1 ) * D [ i - 1 , j - 1 ]), 5 ) print ( D [ i , 0 : i + 1 ]) return D def f ( x ): return x ** math . cos ( x ) x = 0.6 h = 0.1 n = 2 print ( '=Tabel Richardson= \\n ' ) print ( 'f(x) = x^cos(x) \\n ' ) hasil = richardson_extrapolation ( f , x , h , n ) print ( 'hasil estimasi terbaik adalah' , hasil [ n , n ]) output hasil : = Tabel Richardson = f ( x ) = x ^ cos ( x ) [ 1.08483 ] [ 1.08988 1.09156 ] [ 1.09115 1.09157 1.09157 ] hasil estimasi terbaik adalah 1.09157","title":"Program Python"},{"location":"6eu/","text":"TUGAS 6 - Persamaan Diferensial Biasa dengan Metode Euler \u00b6 Deskripsi \u00b6 Persamaan diferensial biasa adalah persamaan diferensial di mana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel bebas tunggal. Dalam bentuk paling sederhana fungsi yang tidak diketahui ini adalah fungsi riil atau fungsi kompleks, tetapi secara umum bisa juga berupa fungsi vektor maupun matriks. Lebih jauh lagi, persamaan diferensial biasa digolongkan berdasarkan orde tertinggi dari turunan terhadap variabel terikat yang muncul dalam persamaan tersebut. Persamaan diferensial biasa muncul dalam berbagai keadaan, termasuk geometri, mekanika, astronomi dan pemodelan populasi. Banyak matematikawan ternama telah mempelajari persamaan diferensial dan memberi sumbangan terhadap bidang studi ini, termasuk Isaac Newton, Gottfried Leibniz, keluarga Bernoulli, Riccati, Clairaut, d'Alembert, dan Euler. Metode Euler \u00b6 Penyelesaian persamaan deferensial biasa dengan metode Euler sangat sederhana, akan tetapi hasil penyelesaiannya sering merupakan penyelesaian pendekatan dengan nilai error yang cukup besar. Biasanya untuk mengurangi nilai errornya diambil E x yang cukup kecil, akan tetapi hal ini akan menambah jumlah iterasinya. Misal pada contoh kasus berikut, untuk menyelesaikan persamaan differensial biasa dengan metode Euler \\frac{d y}{d x}=1+x^{2}, \\quad y(1)=-4 \\frac{d y}{d x}=1+x^{2}, \\quad y(1)=-4 supaya memudahkan dalam perhitungan, maka dibuatlah program menggunakan python yang bisa dilihat dibawah ini; print ( \"f(x,y)=1+x^2\" ) print ( \"yi+1 = y1 + hf(xi+yi)\" ) x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) h = 1.01 - x1 #Langsung saya atur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n = 4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = - 4 hasil = xi y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil pada bagian pertama terdapat variable x_1 x_1 adalah x x awal dan x_2 x_2 merupakan x x akhir. karena di soal terdapat n_x n_x =3 yaitu x_0 x_0 =1, x_1 x_1 =1.01, x_2 x_2 =1.03, x_3 x_3 =1.02 maka h= x_n - x_0/n h= x_n - x_0/n , maka h h = 0.01 adalah hasilnya. x_i x_i adalah hasil awal yang kemudian akan dimasukkan pada prosess iterasi. Karena rumus euler adalah y_1 = y_0 + h(f(x,y)) y_1 = y_0 + h(f(x,y)) maka rumus barunya adalah y_1 = y_0 + h(1+x^2) y_1 = y_0 + h(1+x^2) . variable y y digunakan untuk penambahan nilai x x agar selalu bertambah 0.01 atau increment.","title":"6-PDB dengan Metode Euler"},{"location":"6eu/#tugas-6-persamaan-diferensial-biasa-dengan-metode-euler","text":"","title":"TUGAS 6 - Persamaan Diferensial Biasa dengan Metode Euler"},{"location":"6eu/#deskripsi","text":"Persamaan diferensial biasa adalah persamaan diferensial di mana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel bebas tunggal. Dalam bentuk paling sederhana fungsi yang tidak diketahui ini adalah fungsi riil atau fungsi kompleks, tetapi secara umum bisa juga berupa fungsi vektor maupun matriks. Lebih jauh lagi, persamaan diferensial biasa digolongkan berdasarkan orde tertinggi dari turunan terhadap variabel terikat yang muncul dalam persamaan tersebut. Persamaan diferensial biasa muncul dalam berbagai keadaan, termasuk geometri, mekanika, astronomi dan pemodelan populasi. Banyak matematikawan ternama telah mempelajari persamaan diferensial dan memberi sumbangan terhadap bidang studi ini, termasuk Isaac Newton, Gottfried Leibniz, keluarga Bernoulli, Riccati, Clairaut, d'Alembert, dan Euler.","title":"Deskripsi"},{"location":"6eu/#metode-euler","text":"Penyelesaian persamaan deferensial biasa dengan metode Euler sangat sederhana, akan tetapi hasil penyelesaiannya sering merupakan penyelesaian pendekatan dengan nilai error yang cukup besar. Biasanya untuk mengurangi nilai errornya diambil E x yang cukup kecil, akan tetapi hal ini akan menambah jumlah iterasinya. Misal pada contoh kasus berikut, untuk menyelesaikan persamaan differensial biasa dengan metode Euler \\frac{d y}{d x}=1+x^{2}, \\quad y(1)=-4 \\frac{d y}{d x}=1+x^{2}, \\quad y(1)=-4 supaya memudahkan dalam perhitungan, maka dibuatlah program menggunakan python yang bisa dilihat dibawah ini; print ( \"f(x,y)=1+x^2\" ) print ( \"yi+1 = y1 + hf(xi+yi)\" ) x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) h = 1.01 - x1 #Langsung saya atur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n = 4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = - 4 hasil = xi y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil pada bagian pertama terdapat variable x_1 x_1 adalah x x awal dan x_2 x_2 merupakan x x akhir. karena di soal terdapat n_x n_x =3 yaitu x_0 x_0 =1, x_1 x_1 =1.01, x_2 x_2 =1.03, x_3 x_3 =1.02 maka h= x_n - x_0/n h= x_n - x_0/n , maka h h = 0.01 adalah hasilnya. x_i x_i adalah hasil awal yang kemudian akan dimasukkan pada prosess iterasi. Karena rumus euler adalah y_1 = y_0 + h(f(x,y)) y_1 = y_0 + h(f(x,y)) maka rumus barunya adalah y_1 = y_0 + h(1+x^2) y_1 = y_0 + h(1+x^2) . variable y y digunakan untuk penambahan nilai x x agar selalu bertambah 0.01 atau increment.","title":"Metode Euler"},{"location":"7comproblem/","text":"TUGAS 7 - Menyelesaikan Persoalan Integral dengan Metode Monte Carlo \u00b6 Deskripsi \u00b6 Metode Monte Carlo adalah suatu metode komputasi yang mengambil sampel tak teratur secara berulang guna memperoleh hasil numerik yang mendekati nilai sesungguhnya. Metode ini sering dipakai dalam menyelesaikan permasalahan matematika dan fisika, terutama saat pendekatan yang lain tidak memungkinkan. Dalam metode ini, perkiraan persoalan integral bisa menggunakan \\begin{array}{l} \\int_{0}^{1} f(x) d x \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}\\right) \\end{array} \\begin{array}{l} \\int_{0}^{1} f(x) d x \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}\\right) \\end{array} \\begin{array}{l} \\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} f(x, y, z) d x d y d z \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}, y_{i}, z_{i}\\right) \\end{array} \\begin{array}{l} \\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} f(x, y, z) d x d y d z \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}, y_{i}, z_{i}\\right) \\end{array} nb: x_i x_i : urutan angka acak x_i, y_i, z_i x_i, y_i, z_i : urutan acak N cube Tugas Programing \u00b6 Write program to verify numerically that \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} . Use the Monte Carlo method and 2500 random numbers. Use the Monte Carlo method to approximate the integral. \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z jawaban no 1 \u00b6 Berikut adalah program berdasarkan soal diatas dengan bahasa python, untuk menjalankan pengujian bahwa \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} dan angka acak 2500. import random as r analitik = 3.14159 count = 2500 x0 = 0 ; x1 = 2 def monte_carlo ( f , count , x0 , x1 ): in_area = 0.0 for i in range ( count ): x_ = r . uniform ( x0 , x1 ); if x0 <= x_ <= x1 : in_area += f ( x_ ) area_box = ( x1 - x0 ) return (( in_area / count ) * area_box ) def f ( x ): return (( 4 - x ** 2 ) ** ( 1 / 2 )) hasil = monte_carlo ( f , count , x0 , x1 ) print ( 'N =' , count ) print ( 'Hasil aproksimasi:' , hasil ) print ( 'Relative true error:' , ( analitik - hasil ) / analitik , '|' , str ( round ((( analitik - hasil ) / analitik ) * 100 , 2 )) + '%' ) inilah hasil runing dari program di atas; N = 2500 Hasil aproksimasi : 3.1169340168166424 Relative true error : 0.007848249829977014 | 0.78 % N = 5000 Hasil aproksimasi : 3.1415150955638516 Relative true error : 2.3842842684222457e-05 | 0.0 % pembahasan no 1 \u00b6 Dalam program ini, memiliki library random untuk mendapatkan nilai acak. program ini memiliki variabel analitik yg berisi nilai perhitungan secara analitik/nilai sebernarnya. Lalu memiliki variabel count untuk N (banyaknya perulangan), variabel x0 untuk batas bawah dan x1 untuk batas atas integral. Didalam fungsi monte_carlo(param1,param2..) ini, memiliki paramater f untuk fungsi integral yg akan digunakan, count, x0, dan x1. Lalu dalam fungsi ini memiliki variable in_area , dimana variabel ini akan digunakan untuk menampung nilai acak yg dihasilkan pada area dari persamaan ini. kemudian memiliki looping yg akan mengulang sebanyak N. Dalam perulangan ini, tedapat variabel x_ untuk nilai acak dalam rentang x0 dan x1. Kemudian akan akan dilakukan pengecekan kembali apabila nilai dari x_ dalam rentang x0 dan x1, maka akan menjumlah terus menerus nilai dari perhitungan f(x) , dimana ilustrasinya nilai ini merupakan titik dalam bentang persamaan yg didefinisikan. Setelah melakukan looping sebanyak N, maka akan mencari nilai dari area_box, area_box merupakan area dalam interval x0 dan x1 yg berbentuk kotak. Lalu fungsi ini akan mengembalikan nilai dari perhitungan rata-rata dari in_area dikali dengan area_box. jawaban no 2 \u00b6 Sedangkan untuk jawaban nomor 2 adalah mengaproksimasikan nilai integral \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z import random as r analitik = 8.0 count = 1000 x0 = - 1 ; x1 = 1 ; y0 = - 1 ; y1 = 1 ; z0 = - 1 ; z1 = 1 def monte_carlo ( f , count , x0 , x1 , y0 , y1 , z0 , z1 ): in_area = 0.0 for i in range ( count ): x_ = r . uniform ( x0 , x1 ); y_ = r . uniform ( x0 , x1 ); z_ = r . uniform ( z0 , z1 ); if ( x0 <= x_ <= x1 ) and ( y0 <= y_ <= y1 ) and ( z0 <= z_ <= z1 ): in_area += f ( x_ , y_ , z_ ) area = ( x1 - x0 ) * ( y1 - y0 ) * ( z1 - z0 ) return ( in_area / count ) * area def f ( x , y , z ): return ( x ** 2 + y ** 2 + z ** 2 ) hasil = monte_carlo ( f , count , x0 , x1 , y0 , y1 , z0 , z1 ) print ( 'N =' , count ) print ( 'Hasil aproksimasi:' , hasil ) print ( 'Relative true error:' , ( analitik - hasil ) / analitik , '|' , str ( round ((( analitik - hasil ) / analitik ) * 100 , 2 )) + '%' ) pembahasan no 2 \u00b6 hasil runing N = 1000 Hasil aproksimasi : 7.918782014912802 Relative true error : 0.010152248135899766 | 1.02 % N = 5000 Hasil aproksimasi : 7.974525782192673 Relative true error : 0.0031842772259158547 | 0.32 % Dari hasil running program diatas, program pertama digunakan N sebanyak 1000, maka diperoleh nilai aproksimasi, yaitu 7.918782014912802 dg relative true error sebesar 1.02%. Kemudian pada running yang kedua menggunakan N sebanyak 5000, maka hasil aproksimasi yaitu 7.974525782192673 dg relative true error sebesar 0.32%. Nilai perkiraan yang diperoleh akan dinamis setiap program dijalankan, terkadang error lebih besar atau lebih kecil. Namun, dg memberikan nilai N yang lebih besar error yang diperoleh dominan lebih kecil. pada program ini hampir sama dg program pertama, hanya saja pada program ini untuk mengaproksimasi integral lapis 3. Kemudian x0 dan x1 untuk integral pertama, y0 dan y1 untuk integral kedua, dan z0 dan z1 untuk integral ketiga. Proses perhitungan dan penyelesaian yang dilakukan hampir sama dg program pertama, yaitu dg menggunakan angka random pada rentang yang ditentukan, dan titiknya juga berada pada dimensi yang berbeda. Dan dibawah ini merupakan proses analitik dari integral tersebut, dimana hasil analitiknya adalah 8. \\begin{array}{l} I=\\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{3}\\right) d x d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3} x^{3}+y^{2}+z^{2}\\right]_{-1}^{1} d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3}(1) x^{3}+(1) y^{2}+(1) z^{2}\\right]-\\left[\\frac{1}{3}(-1) x^{3}+(-1) y^{2}+(-1) z^{2}\\right] \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left(\\frac{2}{3}+2 y^{2}+2 z^{2}\\right) d y d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3} y+\\frac{2}{3} y^{3}+2 z^{2} y\\right]_{-1}^{1} d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3}(1)+\\frac{2}{3}(1)^{3}+2 z^{2}(1)\\right]-\\left[\\frac{2}{3}(-1)+\\frac{2}{3}(-1)^{3}+2 z^{2}(-1)\\right] \\\\ I=\\int_{-1}^{1}\\left(\\frac{8}{3}+4 z\\right) d z \\end{array} \\begin{array}{l} I=\\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{3}\\right) d x d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3} x^{3}+y^{2}+z^{2}\\right]_{-1}^{1} d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3}(1) x^{3}+(1) y^{2}+(1) z^{2}\\right]-\\left[\\frac{1}{3}(-1) x^{3}+(-1) y^{2}+(-1) z^{2}\\right] \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left(\\frac{2}{3}+2 y^{2}+2 z^{2}\\right) d y d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3} y+\\frac{2}{3} y^{3}+2 z^{2} y\\right]_{-1}^{1} d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3}(1)+\\frac{2}{3}(1)^{3}+2 z^{2}(1)\\right]-\\left[\\frac{2}{3}(-1)+\\frac{2}{3}(-1)^{3}+2 z^{2}(-1)\\right] \\\\ I=\\int_{-1}^{1}\\left(\\frac{8}{3}+4 z\\right) d z \\end{array} \\begin{array}{l} =\\left[\\frac{8}{3}(1)+\\frac{4}{3}(1)^{3}\\right]-\\left[\\frac{8}{3}(-1)+\\frac{4}{3}(-1)^{3}\\right] \\\\ =\\frac{24}{3} \\\\ =8 \\end{array} \\begin{array}{l} =\\left[\\frac{8}{3}(1)+\\frac{4}{3}(1)^{3}\\right]-\\left[\\frac{8}{3}(-1)+\\frac{4}{3}(-1)^{3}\\right] \\\\ =\\frac{24}{3} \\\\ =8 \\end{array} Sehingga dapat disimpulkan bahwa dari proses analitis menggunakan program hampir mendekati, tergantung dari banyak angkanya yang dimasukan. Semakin banyak angka atau nilai jumlah N, maka semakin sedikit estimasi erornya. Sekian, terima kasih :)","title":"7-Metode Monte Carlo"},{"location":"7comproblem/#tugas-7-menyelesaikan-persoalan-integral-dengan-metode-monte-carlo","text":"","title":"TUGAS 7 - Menyelesaikan Persoalan Integral dengan Metode Monte Carlo"},{"location":"7comproblem/#deskripsi","text":"Metode Monte Carlo adalah suatu metode komputasi yang mengambil sampel tak teratur secara berulang guna memperoleh hasil numerik yang mendekati nilai sesungguhnya. Metode ini sering dipakai dalam menyelesaikan permasalahan matematika dan fisika, terutama saat pendekatan yang lain tidak memungkinkan. Dalam metode ini, perkiraan persoalan integral bisa menggunakan \\begin{array}{l} \\int_{0}^{1} f(x) d x \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}\\right) \\end{array} \\begin{array}{l} \\int_{0}^{1} f(x) d x \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}\\right) \\end{array} \\begin{array}{l} \\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} f(x, y, z) d x d y d z \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}, y_{i}, z_{i}\\right) \\end{array} \\begin{array}{l} \\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} f(x, y, z) d x d y d z \\approx \\frac{1}{n} \\sum_{i=0}^{n} f\\left(x_{i}, y_{i}, z_{i}\\right) \\end{array} nb: x_i x_i : urutan angka acak x_i, y_i, z_i x_i, y_i, z_i : urutan acak N cube","title":"Deskripsi"},{"location":"7comproblem/#tugas-programing","text":"Write program to verify numerically that \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} . Use the Monte Carlo method and 2500 random numbers. Use the Monte Carlo method to approximate the integral. \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z","title":"Tugas Programing"},{"location":"7comproblem/#jawaban-no-1","text":"Berikut adalah program berdasarkan soal diatas dengan bahasa python, untuk menjalankan pengujian bahwa \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} \\pi=\\int_{0}^{2}\\left(4-x^{2}\\right)^{1 / 2} dan angka acak 2500. import random as r analitik = 3.14159 count = 2500 x0 = 0 ; x1 = 2 def monte_carlo ( f , count , x0 , x1 ): in_area = 0.0 for i in range ( count ): x_ = r . uniform ( x0 , x1 ); if x0 <= x_ <= x1 : in_area += f ( x_ ) area_box = ( x1 - x0 ) return (( in_area / count ) * area_box ) def f ( x ): return (( 4 - x ** 2 ) ** ( 1 / 2 )) hasil = monte_carlo ( f , count , x0 , x1 ) print ( 'N =' , count ) print ( 'Hasil aproksimasi:' , hasil ) print ( 'Relative true error:' , ( analitik - hasil ) / analitik , '|' , str ( round ((( analitik - hasil ) / analitik ) * 100 , 2 )) + '%' ) inilah hasil runing dari program di atas; N = 2500 Hasil aproksimasi : 3.1169340168166424 Relative true error : 0.007848249829977014 | 0.78 % N = 5000 Hasil aproksimasi : 3.1415150955638516 Relative true error : 2.3842842684222457e-05 | 0.0 %","title":"jawaban no 1"},{"location":"7comproblem/#pembahasan-no-1","text":"Dalam program ini, memiliki library random untuk mendapatkan nilai acak. program ini memiliki variabel analitik yg berisi nilai perhitungan secara analitik/nilai sebernarnya. Lalu memiliki variabel count untuk N (banyaknya perulangan), variabel x0 untuk batas bawah dan x1 untuk batas atas integral. Didalam fungsi monte_carlo(param1,param2..) ini, memiliki paramater f untuk fungsi integral yg akan digunakan, count, x0, dan x1. Lalu dalam fungsi ini memiliki variable in_area , dimana variabel ini akan digunakan untuk menampung nilai acak yg dihasilkan pada area dari persamaan ini. kemudian memiliki looping yg akan mengulang sebanyak N. Dalam perulangan ini, tedapat variabel x_ untuk nilai acak dalam rentang x0 dan x1. Kemudian akan akan dilakukan pengecekan kembali apabila nilai dari x_ dalam rentang x0 dan x1, maka akan menjumlah terus menerus nilai dari perhitungan f(x) , dimana ilustrasinya nilai ini merupakan titik dalam bentang persamaan yg didefinisikan. Setelah melakukan looping sebanyak N, maka akan mencari nilai dari area_box, area_box merupakan area dalam interval x0 dan x1 yg berbentuk kotak. Lalu fungsi ini akan mengembalikan nilai dari perhitungan rata-rata dari in_area dikali dengan area_box.","title":"pembahasan no 1"},{"location":"7comproblem/#jawaban-no-2","text":"Sedangkan untuk jawaban nomor 2 adalah mengaproksimasikan nilai integral \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{2}\\right) d x d y d z import random as r analitik = 8.0 count = 1000 x0 = - 1 ; x1 = 1 ; y0 = - 1 ; y1 = 1 ; z0 = - 1 ; z1 = 1 def monte_carlo ( f , count , x0 , x1 , y0 , y1 , z0 , z1 ): in_area = 0.0 for i in range ( count ): x_ = r . uniform ( x0 , x1 ); y_ = r . uniform ( x0 , x1 ); z_ = r . uniform ( z0 , z1 ); if ( x0 <= x_ <= x1 ) and ( y0 <= y_ <= y1 ) and ( z0 <= z_ <= z1 ): in_area += f ( x_ , y_ , z_ ) area = ( x1 - x0 ) * ( y1 - y0 ) * ( z1 - z0 ) return ( in_area / count ) * area def f ( x , y , z ): return ( x ** 2 + y ** 2 + z ** 2 ) hasil = monte_carlo ( f , count , x0 , x1 , y0 , y1 , z0 , z1 ) print ( 'N =' , count ) print ( 'Hasil aproksimasi:' , hasil ) print ( 'Relative true error:' , ( analitik - hasil ) / analitik , '|' , str ( round ((( analitik - hasil ) / analitik ) * 100 , 2 )) + '%' )","title":"jawaban no 2"},{"location":"7comproblem/#pembahasan-no-2","text":"hasil runing N = 1000 Hasil aproksimasi : 7.918782014912802 Relative true error : 0.010152248135899766 | 1.02 % N = 5000 Hasil aproksimasi : 7.974525782192673 Relative true error : 0.0031842772259158547 | 0.32 % Dari hasil running program diatas, program pertama digunakan N sebanyak 1000, maka diperoleh nilai aproksimasi, yaitu 7.918782014912802 dg relative true error sebesar 1.02%. Kemudian pada running yang kedua menggunakan N sebanyak 5000, maka hasil aproksimasi yaitu 7.974525782192673 dg relative true error sebesar 0.32%. Nilai perkiraan yang diperoleh akan dinamis setiap program dijalankan, terkadang error lebih besar atau lebih kecil. Namun, dg memberikan nilai N yang lebih besar error yang diperoleh dominan lebih kecil. pada program ini hampir sama dg program pertama, hanya saja pada program ini untuk mengaproksimasi integral lapis 3. Kemudian x0 dan x1 untuk integral pertama, y0 dan y1 untuk integral kedua, dan z0 dan z1 untuk integral ketiga. Proses perhitungan dan penyelesaian yang dilakukan hampir sama dg program pertama, yaitu dg menggunakan angka random pada rentang yang ditentukan, dan titiknya juga berada pada dimensi yang berbeda. Dan dibawah ini merupakan proses analitik dari integral tersebut, dimana hasil analitiknya adalah 8. \\begin{array}{l} I=\\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{3}\\right) d x d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3} x^{3}+y^{2}+z^{2}\\right]_{-1}^{1} d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3}(1) x^{3}+(1) y^{2}+(1) z^{2}\\right]-\\left[\\frac{1}{3}(-1) x^{3}+(-1) y^{2}+(-1) z^{2}\\right] \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left(\\frac{2}{3}+2 y^{2}+2 z^{2}\\right) d y d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3} y+\\frac{2}{3} y^{3}+2 z^{2} y\\right]_{-1}^{1} d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3}(1)+\\frac{2}{3}(1)^{3}+2 z^{2}(1)\\right]-\\left[\\frac{2}{3}(-1)+\\frac{2}{3}(-1)^{3}+2 z^{2}(-1)\\right] \\\\ I=\\int_{-1}^{1}\\left(\\frac{8}{3}+4 z\\right) d z \\end{array} \\begin{array}{l} I=\\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1}\\left(x^{2}+y^{2}+z^{3}\\right) d x d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3} x^{3}+y^{2}+z^{2}\\right]_{-1}^{1} d y d z \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left[\\frac{1}{3}(1) x^{3}+(1) y^{2}+(1) z^{2}\\right]-\\left[\\frac{1}{3}(-1) x^{3}+(-1) y^{2}+(-1) z^{2}\\right] \\\\ I=\\int_{-1}^{1} \\int_{-1}^{1}\\left(\\frac{2}{3}+2 y^{2}+2 z^{2}\\right) d y d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3} y+\\frac{2}{3} y^{3}+2 z^{2} y\\right]_{-1}^{1} d z \\\\ I=\\int_{-1}^{1}\\left[\\frac{2}{3}(1)+\\frac{2}{3}(1)^{3}+2 z^{2}(1)\\right]-\\left[\\frac{2}{3}(-1)+\\frac{2}{3}(-1)^{3}+2 z^{2}(-1)\\right] \\\\ I=\\int_{-1}^{1}\\left(\\frac{8}{3}+4 z\\right) d z \\end{array} \\begin{array}{l} =\\left[\\frac{8}{3}(1)+\\frac{4}{3}(1)^{3}\\right]-\\left[\\frac{8}{3}(-1)+\\frac{4}{3}(-1)^{3}\\right] \\\\ =\\frac{24}{3} \\\\ =8 \\end{array} \\begin{array}{l} =\\left[\\frac{8}{3}(1)+\\frac{4}{3}(1)^{3}\\right]-\\left[\\frac{8}{3}(-1)+\\frac{4}{3}(-1)^{3}\\right] \\\\ =\\frac{24}{3} \\\\ =8 \\end{array} Sehingga dapat disimpulkan bahwa dari proses analitis menggunakan program hampir mendekati, tergantung dari banyak angkanya yang dimasukan. Semakin banyak angka atau nilai jumlah N, maka semakin sedikit estimasi erornya. Sekian, terima kasih :)","title":"pembahasan no 2"}]}